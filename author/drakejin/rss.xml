<xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link>blog.drakejin.me</link>
   <description>데이터 분석은 잘 못하지만, 데이터 분석할 수 있게 도와드리겠어요!</description>
   <language>utf-8</language>
   <managingEditor> drakejin</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>(스터디) React 를 알아보자 - 1</title>
	  <link>//Study-react-1</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-26T00:00:00+09:00</pubDate>
	  <guid>//Study-react-1</guid>
	  <description><![CDATA[
	     <p>React.js 으.. 남들 하니까 협업을 위해 한다 .
개인 정리를 위해 만들었으며 모든 지적 재산권은 https://velopert.com/775 에 있습니다.</p>

<h2 id="react--01---">React 강좌 01: 소개 및 맛보기</h2>

<p>React느 페이스북에서 개발한 UI개발 라이브러리, Virtual DOM을 사용하여 금새 
재사용 가능한 UI를 생설할 수 있게 해준다. react는 페이스북, 인스타, 야후, 넷플리스
에서 사용하고 있고 최근은 스타트업의 프론트UI를 주름잡는 녀석이 되었다.</p>

<h2 id="virtual-dom">Virtual DOM</h2>

<h4 id="dom--">DOM 의 이해</h4>
<p>DOM은 Document Object Model 의 야사. 이는 객체를 통하여 구조화된 문서를 표현하는 방법
XML 또는 HTML로 작성된다. 웹 브라우저는 DOM을 활용하여 객체에 Javascript와 CSS를 적용하고 있다. DOM은 트리형태로 되어있어서 수정, 삭제, 생성에 용이하다.</p>

<h4 id="dom-">DOM의 문제점</h4>
<ul>
  <li>동적 UI(서버와 통신이 잦은 Web Service)에 최적화 되어있지 않다.</li>
  <li>큰 규모의 서비스에서는 수 많은 데이터가 웹으로 로드되어야 하며, 한 DOM객체에 대한것이 아닌 여러 객체에 대해서 CRUD가 이뤄진다.</li>
</ul>

<blockquote>
  <p>잘못알고 있는 상식 
1. DOM은 무겁다.
2. Javascript 접근이 DOM 직접 접근 보다 빠르다 
  - 이는 사실이 아니며 DOM자체는 빠르다. 다만 브라우저 단에서 DOM의 변화가 일어나면 브라우저가 CSS를 다시 연산하고 레이아웃을 다시 구성하고, 웹페이지를 다시 리페인트 하는데, 이 과정에서 시간이 많이 허비되게 된다. 
  - 레이아웃을 새로 구성하면서 계산하는것이 reflow
  - 색상변경과 같은 레이아웃에 관계없는 것들을 처리하는것이 repaint</p>
</blockquote>

<p>``` javascript
var style = document.body.style; // 캐싱 
style.padding = “20px” // reflow, repaint
style.border = “10px solid red” // reflow, repaint</p>

<p>style.color = “blue” // repaint
style.backgroundColor = “#ffa”  // repaint</p>

<p>style.fontSize = “1em”  // reflow, repaint</p>

<p>document.body.appendChild(document.createTextNode(‘hello world!’));
// reflow, repaint</p>

<p>//—– d이것 이외에도 값을 조회만 할 때에도 reflow가 계산된다.
element.offsetLeft      // reflow
element.clientWidth     // reflow
element.getClientRects() // reflow
```</p>

<h4 id="section">브라우저는 바보가 아니다.</h4>
<p>위와 같이 언급한 부분에서는 별것 아닌 작업에도 reflow와 repaint작업이 발생하게됩니다. 
실제로 저런 작업이 실행되면 성능저하를 줄이기 위해 매우 짧은 시간내에 여러 reflow가 발생하려고 할 시 이 작업을 미루고 한꺼번에 처리합니다.</p>

<blockquote>
  <p>단, 일부 코드들 offsetTop, scrollTop, getComputedStyle()등의 코드가 실행 될 때는 현재의 값을 가져오는것들이 중요하기 떄문에 reflow가 여러번 발생할 수 밖에 없게 된다.</p>
</blockquote>

<h4 id="reflow-repaint-">Reflow와 Repaint 해결</h4>
<p>Virtual DOM을 이용하면 실제 DOM에 접근하여 조작하는 대신에, 이를 추상화 시킨 자바스크립트 객체를 구성하여 사용하면 됩니다.
 Virtual DOM은 실제 DOM의 가벼운 사본과 같은 역할을 합니다 .</p>

<ol>
  <li>DOM에 대한 데이터 업데이트가 되면, 전체 UI를 Virtual DOM 에 렌더링 합니다.</li>
  <li>이전 Virtual DOM에 있던 내용과 현재의 내용을 비교합니다.</li>
  <li>바뀐 부분에만 실제 DOM에 적용 됩니다.</li>
</ol>

<blockquote>
  <p>오해 
“React는 항상 빨라!! 빠르다규!”</p>

  <p>React는 무조건 빠른게 아니다. 지속해서 데이터가 변화하는 대규모 애플리케이션에 구축하기 위해 
React를 만들었다.</p>
</blockquote>

<h2 id="react">React</h2>

<h3 id="react-">React 특징</h3>
<ul>
  <li>Virtual DOM을 사용한다.</li>
  <li>JSX : JSX는 javascript의 확장 문법으로써 babel이 이 확장문법을 파싱해주며, React.Component(asd,asd,asd,asd,asd,)의 형태로 변형해준다. 써도그만 안써도 그만, 안쓰면 불편할 뿐</li>
  <li>Components: React는 모두 Component에 대한 것, React 개발을 할 때에는 Component로써 생각해야 한다.</li>
</ul>

<h3 id="react--1">React의 장점</h3>
<ul>
  <li>Virtual DOM을 사용한 어플리케이션의 성능향상</li>
  <li>클라이언트에서 렌더링 될 수 있고 서버측에서도 렌더링 될 수 있음.</li>
  <li>브라우저측의 초기 렌더링 딜레이를 줄이고, SEO호환도 가능해진다.</li>
  <li>Component의 가독성이 매우 높고 간단하여 쉬운 유지보수가 가능해진다.</li>
  <li>프레임워크가 아닌 라이브러리이기 때문에 타 프레임워크와 혼합 사용이 가능하다.</li>
  <li>React에선 UI만 신경쓰고 나머지 라우팅기능은 프레임워크..</li>
</ul>

<h3 id="section-1">제한</h3>
<ul>
  <li>어플리케이션의 View레이어만 다루므로 이 외의 부분은 다른 기술을 사용해야 한다. (Ajax, Router등등..)</li>
  <li>React 버전 v15부터는 IE8 이하 버전을 지원하지 않는다.</li>
</ul>

<h3 id="section-2">맛보기</h3>
<ul>
  <li>React프로젝트를 시작하려면 node.js와 NPM을 설정하고 이것저것 서정을 많이 해야한다 - React를 맛보기 위해 유용하고 편한 웹 서비스인 webpackbin을 사용해보겠다.</li>
</ul>

<ol>
  <li>상단 메뉴의 Boilerplated &gt; React클릭</li>
  <li>index.html, main.js, HelloWorld.js파일이 생긴다.</li>
</ol>

<h4 id="helloworldjs">HelloWorld.js</h4>

<p>``` javascript
import React from ‘react’</p>

<p>function HelloWorld(){
    return (
        &lt;h1&gt; Hello World !&lt;/h1&gt;
    );
}</p>

<p>export default HelloWorld</p>

<p>```
소스코드 설명</p>

<ol>
  <li>상단의 import는 ES6문법으로 사용되며 <em>var React = require(‘react’)</em> 는 동일한 의미이다. require는 Node.js의 것으로 클라이언트 사이드에선 보통 html태그를 이용하여 script를 여럿 불러오지만, require를 이용하지 않습니다. 지원도 하지 않고..</li>
  <li>Bundling webpack이라는 도구를 이용하여 Node.js에서 require하는것과 같이 모듈을 불러올 수 있께 하는 것. Webpack은 이렇게 import(혹은 require)한 모듈을 불러와서 한 파일로 합친다.</li>
  <li>babel-loader는</li>
</ol>

<p><code class="highlighter-rouge">javascript 
    return React.createElement(&lt;h1&gt;Hello World!&lt;/h1&gt;)
</code>
를 
<code class="highlighter-rouge">javascript 
    return React.createElement(
        "h1",
        null,
        "Hello World!"
    );
</code>
로 변환시킨다. JSX =&gt; Javascript</p>

<h4 id="mainjs">main.js</h4>

<p>``` javascript
import React from ‘react’;
import {render} from ‘react-dom’
import HelloWorld from ‘./HelloWorld.js’</p>

<p>render(<helloworld></helloworld>), document.querySelector(“#app”));</p>

<p>```
main.js에서는 HelloWorld.js 에서 만든 컴포넌트를 불러와서 페이지에 렌더링 합니다.</p>

<p>이 파일은webpack의 entry파일 입니다. 여기서부터 import 하는 파일들을 재귀적으로 모두 불러와서 하나의 파일로 합치게 됩니다. 
React컴포넌트를 페이지에 렌더링 할 때에는 react-dom모듈을 불러와서 render함수를 통하여 처리합니다.</p>

<p>여기서 render 함수의 첫 번째 파라미터는 렌더링 할 JSX 형태의 코드 입니다. 여기서는 HelloWorld컴포넌트를 렌더링 하도록 설정하였습니다. 
이런식으로 컴포넌트를 만들면 _<컴포넌트이름></컴포넌트이름>_이런식으로 HTML태그를 작성하듯이 쓸 수 있는것입니다.</p>

<p>두번째 파라메터는 렌더링할 HTML요소 입니다. id가 app인 DOM객체에 렌더링하게 설정했습니다.  이는 index.html에서 찾아볼 수 있습니다 .</p>

<h4 id="indexhtml">index.html</h4>

<p>``` javascript</p>
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <div id="app"></div>
        <script src="main.js"></script>
    </body> 
</html>

<p>```</p>

<h3 id="section-3">컴포넌트에 속성을 줘보자 .</h3>
<p>HelloWorld컴포넌트에 속성을 만들어본다. 코드를 다음과 같이 수정해보자.</p>

<h4 id="helloworldjs-1">HelloWorld.js</h4>

<p>``` javascript
import React from ‘react’;
function HelloWorld (props){
    return (
        &lt;h1&gt; Hello {props.name}!&lt;/h1&gt;
    );
}</p>

<p>export default HelloWorld;
```</p>

<p>함수에 props 파라미터를 추가하고, 이 props.name값을 JSX안에서 렌더링 하도록 하였다. 
JavaScript값을 JSX에서 렌더링 할 때에는 {  }안에 감싸면 JSX가 알아서 값을 가져옵니다.</p>

<p>``` main.js</p>

<p>import React from ‘react’;
import {render} from ‘react-dom’;
import HelloWorld from ‘./HelloWorld.js’</p>

<p>render(<helloworld name="velopert"></helloworld>, document.querySelector(“#app”));
```</p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) go 언어를.arabokka - 3 [Go의 철학, 특징]</title>
	  <link>//Study-go-3</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-24T00:00:00+09:00</pubDate>
	  <guid>//Study-go-3</guid>
	  <description><![CDATA[
	     <p>사람들에게 물어보았다. 고의 철학과 정의 및 페러다임.</p>

<h4 id="go---6-">Go 언어를 공부한지 6일 째</h4>
<p>고 언어의 철학과 개발자들의 인식 그리고 이 언어에 대한 소감을 알고싶어졌다.</p>

<h3 id="go---">Go 의 강조되는 특징</h3>
<ul>
  <li>고 언어의 동시성 패턴 ( 고 루틴과 채널 <a href="https://www.youtube.com/watch?v=4g2skln42eo">영상 그리고 영상게시글에 있는 ppt 자료</a>)</li>
</ul>

<h3 id="section">고 언어의 페러다임</h3>
<p>없지도 않고 있지도 않다. 이 언어가 무슨 페러다임이다! 라고 명확히 정의 내릴 수 없는 그런 언어.
위키에서는  <a href="/assets/resource/paradigm-compiler.pdf">Paradigm compiled</a>, <a href="http://blog.lgcns.com/1083">concurrent</a> = <a href="http://arcsit.tistory.com/entry/Thread-%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">동시성 프로그래밍</a>,
 <a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">imperative</a>,
 <a href="https://ko.wikipedia.org/wiki/%EA%B5%AC%EC%A1%B0%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">structured</a> 언어로 구분하지만,
 <a href="https://opentutorials.org/course/743/6544">Closure</a>는 되지만 
함수형 헬퍼가 공식제공되는 언어도 아니다. 그렇기 때문에 무척 애매할 수 밖에없다.</p>

<h3 id="section-1">다양한 사람들의 의견</h3>
<ol>
  <li>
    <p>makes it easy to build simple, reliable, and efficient software.
간단하고 안정적이며 효율적인 소프트웨어를 쉽게 만들 수 있습니다.
<a href="https://golang.org">https://golang.org</a> 의 공식 소개 말</p>
  </li>
  <li>(책을 추천해주기도 했다.)<a href="https://l.facebook.com/l.php?u=http%3A%2F%2Fm.yes24.com%2FGoods%2FDetail%2F23381617%3Fscode%3D029&amp;h=ATMuZHeCJEmk7x7zKgZ_LXWs-mAQkDUFe8EKHoLWz1SvyScXVzEoklSPMnu5UqtTyFt9dNeN5EQMSv8ClLr0DLVFyOH-1bTZVb3q8ugQiLle7EZQ7MRXY2AmdV5RyO9sT4DFy6rDxWLh">(도서)하룻밤에 읽는 Go 언어 이야기</a></li>
  <li>개발자의 실력수준을 적게 타서 다양한 수준의 개발자 팀 구성시 유리한 실용적 언어이면서 시대적으로 뒤떨어지지 않는 언어라 생각합니다.</li>
</ol>

<h2 id="section-2">레전설의 답변</h2>
<ul>
  <li><a href="https://www.facebook.com/jhonghee.park?fref=ufi">Jhonghee Park</a>(Go lang Korea 운영진) 님이 생각하는 Go의 정의 및 철학을 일단 맛본다면 조금은 감이 잡히지 않을까 한다.</li>
</ul>

<blockquote>
  <p>” 제가 아는 Go는 그닥지 철학적이지도 학자연 하지도 않은 언어네요. 
타입 시스템에 관심이 많고 언어이론에 통달하신 분들 한테는 재미 하나도 없는 언어이고
객체지향이던 함수형이던 어떤 특정한 프로그래밍 패러다임의 렌즈로 들여다 보기 시작하면 
모든 분야에 2% 모자라는 언어입니다. “</p>

  <p>” 프로그래밍 언어 개발을 전문적을 하는 분들이 모여 만든 언어도 아니고
단지 언어를 개발할 능력이 있는 고수들이 자기들의 필요를 충족시키기 위해 시작한 언어인지라 지극히 실용성에 촛점을 맞춘 언어라고 볼 수 있지요.
Brad Fitzpatrick가 말한대로 “Get shit done language”라고 보입니다.
단순함과 간결함을 장점으로 유지하기 위해 애쓰기 때문에 다른 언어들에 비해 
개발시 <a href="https://www.teachingenglish.org.uk/article/cognitive-overload">Cognitive overload</a> 현상이 덜합니다.”</p>

  <p><a href="https://en.wikipedia.org/wiki/Object_composition">Object Composition</a>, <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Composition Over inheritance</a>, <a href="https://ko.wikipedia.org/wiki/%EA%B3%A0%EC%B0%A8_%ED%95%A8%EC%88%98">Higher-Order function</a>, <a href="http://blog.jeonghwan.net/js/2017/04/23/Purity-Immutability-and-Policies-for-Change.html">purity of function and immutability of function that feature of functional programming</a>,</p>

  <p>” 멀티 패러다임 언어이지만 각 패러다임의 모든 것을 구현하지는 않습니다. 
객체지향이지만 전통적인 의미의 상속대신 composition을 강조하는 언어이고
 higer-order function, closure등을 이용해 함수형 언어처럼 쓸 수는 있지만 
함수의 purity나 공유데이터의 immutability를 보장하지도 않습니다. 
Go언어 자체에 많은 걸 기대하시면 실망만 남습니다 “</p>
</blockquote>

<p>그리고 이런 답변이 달렸다.</p>

<blockquote>
  <p>제가 Go 언어에 대해 생각하는것과 비슷해서 여쭙습니다.
 한가지 궁금했던 점은 말씀하신 것 처럼 Go의 inheritance 대신 composition 을 강조하는 언어 설계 특성인데 왜 이런 결론에 도달했을까요. <a href="https://kldp.org/node/64151">Ingeritance vs Composition : KLDP</a> , <a href="http://aroundck.tistory.com/617">Inheritance &lt; composition</a></p>
</blockquote>

<p>그리고 <a href="https://www.facebook.com/jhonghee.park?fref=ufi">Jhonghee Park</a> 님이 다시 답변을 달았다.</p>

<blockquote>
  <p>우선 대형 소스코드 베이스에서 일해 보신 분들이라면 동의하실 것 같은데 
지난 20년간의 객체지향성의 독주속에서 inheritance의 이론적 명료함이 
실제로 현실에서는 남용, 오용되어 오히려 코드의 가독성을 떨어뜨리고 
복잡성을 높이는 결과를 초래하는 경우가 적지 않았다고 봅니다.</p>

  <p>Go의 디자이너들은 객체지향성에 대해 그런 접근법보다는 
오히려 인터페이스의 장점을 최대로 살릴 수 있는 쪽으로 디자인 했다고 보여지네요. 
그래서 인터페이스 자체도 명시적이지 않고 <a href="https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91">duck typing</a>과 유사한 형태로 가지고 간 것이고요. 
inheritance를 바탕으로 하는 코딩은 배경에 이미 개발자가 
타입의 hierarchy(계층적 구조)를 어느정도 숙지한 상태를 가정하는 경우가 상당하다고 보여집니다.</p>

  <p>하지만 실제 코딩에서 greenfield(<a href="http://www.donnfelker.com/software-development-greeenfield-vs-brownfield/">Greenfield dev. vs Brwonfield dev.</a>) 프로젝트만을 할 수 없고 
대부분 남이 만들어 놓은 코드를 확장하던지 조합해야 하는데 
inheritance를 주무기로 했을때 이미 또 다른 abstraction의 층을 구성하게 되는 결과를 만듭니다. 
복잡성이 수직적으로 자라는 약순환이 시작되는 것이지요. 
Go언어의 디자이너들을 이런 점을 피하고자 했던게 아닐까요.</p>
</blockquote>

<p>다시 응답이 달렸다.</p>

<blockquote>
  <p>일리있는 말씀 감사합니다. 애초에 다루는 문제가 자연스러운 계층 구조를 가지고 있을 때,
 여전히 inheritance design pattern 을 쓰는게 맞다는 생각은 지울 수 없네요. 
디자인 단계에서 오남용 될 때의 단점이 장점을 상쇄한다고 생각했나보네요. 감사합니다</p>
</blockquote>

<p>그리고 <a href="https://www.facebook.com/jhonghee.park?fref=ufi">Jhonghee Park</a> 님이 다시 답변을 달았다.</p>

<blockquote>
  <p>찾아보니 Golang팀의 공식 입장도 있네요. <a href="https://golang.org/doc/faq#inheritance">go official page#ingeritance</a></p>
</blockquote>

<h4 id="section-3">느낀점 및 결론 그리고 정리 .</h4>
<p>난 솔직히 이 둘이 무슨말을 하는지 모르겠다.
그래서 본문의 단어들이나 키워들을 알 수 있도록 링크를 달아보았다. 
100 퍼센트중에서 20퍼센트밖에 이해못했다. 
역시 난 아직 미숙아인가 보다. 그럼에도 불구하고 갓갓한 분들의 의견을 정리해보면</p>

<ol>
  <li>시스템 언어에 대해 통달한 사람이라면 재미 없는언어. (C 로 짜면 되거든!)
    <ul>
      <li>즉, 시스템 언어에 통달하지 못한사람과 협업하기 위해서는 C보다는 Go를 선택하라.</li>
    </ul>
  </li>
  <li>Go는 어떠한 페러다임의 성질을 가지고 있지만 특정 페러다임이다! 라고 정의내릴 수 없다.
    <ul>
      <li>고차함수와 클로저 비슷한 기능을 지원하여 함수형이라 하자니 함수형 언어의 성질을 보장하지 않음. (함수의 순수성(Purity)이라던지 불변성(Immutability)이라던지..)</li>
      <li>즉.. 단순하게 그냥 멀티페러다임 언어라 부르면 된다.</li>
    </ul>
  </li>
  <li>상속성(Inheritance)과 구성성(Composition) 을 강조하는 언어.
    <ul>
      <li>interface 의 존재로 상속성을 만들수 있지만 애초에 구성성(Composition)이 실제 코드상에서 강조되는 페턴을 짜기 힘들다. 이유는 아무래도 실력인대 괴수가 어렵다하면 나한태도 무척 어려울지도…</li>
      <li>이 어렵다고 하는것은 Ingeritance design pattern 의 오용 및 남용으로 인해 그렇게 느끼는것이라 볼 수 있다.</li>
    </ul>
  </li>
  <li>병렬처리 및 동시성이 강조되는 언어
    <ul>
      <li>Goroutines 과 Channel의 조합이 그러한 특징들을 만들어준다.</li>
    </ul>
  </li>
</ol>


	  ]]></description>
	</item>

	<item>
	  <title>(리뷰-blog) Perfectable 님의 자알쓰 Posting</title>
	  <link>//Review-Blog-perfectable</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-21T00:00:00+09:00</pubDate>
	  <guid>//Review-Blog-perfectable</guid>
	  <description><![CDATA[
	     <p>[데이터공작소] Go언어에 대해 알아볼까요 ?</p>

<h3 id="section">좋은 블로그</h3>
<ol>
  <li>피키캐스트 CTO의 조대협 블로그</li>
  <li>perfectable 님의 자알쓰<br />
 3.</li>
</ol>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) go 언어를.arabojja - 2</title>
	  <link>//Study-go-2</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-20T00:00:00+09:00</pubDate>
	  <guid>//Study-go-2</guid>
	  <description><![CDATA[
	     <p>[데이터공작소]  [don’t copy&amp;past] write &amp; compile &amp; run 배움의 WCR  &gt;  &lt;  !!</p>

<h2 id="section">마라톤 코딩</h2>
<ul>
  <li>소스 정보 <a href="https://gobyexample.com/">gobyexample.com</a></li>
  <li>email : mmcgrana@gmail.com</li>
  <li>twitter :http://twitter.com/mmcgrana</li>
  <li>git : https://github.com/mmcgrana</li>
  <li>한줄평 : 잘생김. 훈훈하게 생김.</li>
</ul>

<p>일단 컴파일이 된다면 대강 한페이지의 코드를 작성하는대 지장없다는 소리다.
그러면… 질릴때까지 예제만 주구장창 쳐보다가 지칠때쯤 다시 이론으로 돌아가보도록 하자.</p>

<ul>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/1.Hello_World.go">1.Hello World.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/2.Values.go">2.Values.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/3.Variables.go">3.Variables.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/4.Constants.go">4.Constants.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/5.For.go">5.For.go</a></li>
  <li>2017-05-20 맛보기만 함…</li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/6.If_Else.go">6.If/Else.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/7.Switch.go">7.Switch.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/8.Arrays.go">8.Arrays.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/9.Slices.go">9.Slices.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/10.Maps.go">10.Maps.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/11.Range.go">11.Range.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/12.Functions.go">12.Functions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/13.Multiple_Return_Values.go">13.Multiple_Return_Values.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/14.Variadic_Functions.go">14.Variadic_Functions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/15.Closures.go">15.Closures.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/16.Recursion.go">16.Recursion.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/17.Pointers.go">17.Pointers.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/18.Structs.go">18.Structs.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/19.Methods.go">19.Methods.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/20.Interfaces.go">20.Interfaces.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/21.Errors.go">21.Errors.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/22.Goroutines.go">22.Goroutines.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/23.Channels.go">23.Channels.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/24.Channel_Buffering.go">24.Channel_Buffering.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/25.Channel_Syncronization.go">25.Channel Synchronization.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/26.Channel_Directions.go">26.Channel Directions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/27.Select.go">27.Select.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/28.Timeouts.go">28.Timeouts.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/29.Non_Blocking_Channel_Operation.go">29.Non-Blocking_Channel_Operations.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/30.Closing_Channels.go">30.Closing Channels.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/31.Range_Over_Channels.go">31.Range over Channels.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/32.Timers.go">32.Timers.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/33.Tickers.go">33.Tickers.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/34.Worker_Pools.go">34.Worker Pools.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/35.Rate_Limiting.go">35.Rate Limiting.go</a></li>
  <li>2017-05-21 36~35 까지 옮겨 치는데 6시간 걸림.</li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/36.Atomic_Counters.go">36.Atomic Counters.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/37.Mutexes.go">37.Mutexes.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/38.Stateful_Goroutines.go">38.Stateful Goroutines.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/39.Sorting.go">39.Sorting.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/40.Sorting_By_Functions.go">40.Sorting by Functions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/41.Panic.go">41.Panic.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/42.Defer.go">42.Defer.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/43.Collection_Functions.go">43.Collection Functions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/44.String_Functions.go">44.String Functions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/45.String_Formatting.go">45.String Formatting.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/46.Regular_Expression.go">46.Regular Expressions.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/47.JSON.go">47.JSON.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/48.Time.go">48.Time.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/49.Epoch.go">49.Epoch.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/50.Time_Formatting_Parsing.go">50.Time Formatting / Parsing.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/51.Random_Numbers.go">51.Random Numbers.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/52.Number_Parsing.go">52.Number Parsing.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/53.URL_Parsing.go">53.URL Parsing.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/54.SHA1_Hashes.go">54.SHA1 Hashes.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/55.Base64_Encoding.go">55.Base64 Encoding.go</a></li>
  <li>2017-05-23 36~55 까지 옮겨 치는데 7시간 걸림</li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/56.Reading_Files.go">56.Reading Files.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/57.Writing_Files.go">57.Writing Files.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/58.Line_Filters.go">58.Line Filters.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/59.Command_Line_Arguments.go">59.Command-Line Arguments.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/60.Command_Line_Flag.go">60.Command-Line Flags.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/61.Environment_Variables.go">61.Environment Variables.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/62.Spawning_Processes.go">62.Spawning Processes.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/63.Execing_Processes.go">63.Exec’ing Processes.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/64.Signals.go">64.Signals.go</a></li>
  <li><a href="https://github.com/drake-jin/go-study/blob/master/ch02/gobyexample/65.Exit.go">65.Exit.go</a></li>
  <li>2017-05-24 56~65 까지 3시간 걸림</li>
</ul>

<h2 id="section-1">예제를 이해하기위해 알고 있어야하는 사전 지식들.</h2>
<ul>
  <li><a href="https://blog.golang.org/go-slices-usage-and-internals">exam 9 - slice and array are different</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Associative_array">exam 10 - Associative data type</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Variadic_function">exam 10 - Variadic Functions</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Anonymous_function">exam 15 - Anonymous Functions</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">exam 15 - Closures</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">exam 16 - Recursion Functions</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Pointer_(computer_programming)">exam 17 - Pointers</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Rate_limiting">exam 35 - Rate_Limiting</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Mutual_exclusion">exam 37 - Mutexes</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Regular_expression">exam 46 - Regular Expressions</a></li>
  <li><a href="http://blog.golang.org/2011/01/json-and-go.html">exam 47 - JSON and GO</a></li>
  <li><a href="http://golang.org/pkg/encoding/json/">exam 47 - JSON package docs</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Unix_time">exam 49 - UNIX Epoch</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">exam 51 - Pseudorandom number generator</a></li>
  <li><a href="http://golang.org/pkg/math/rand/">exam 51 - math/rand package</a></li>
  <li><a href="https://en.wikipedia.org/wiki/SHA-1">exam 54 - SHA-1</a></li>
  <li><a href="https://git-scm.com/">exam 54 - Git Revision Control System</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">exam 54 - Hash Strength</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Command-line_interface#Arguments">exam 59 - Command line arguments </a></li>
  <li><a href="https://en.wikipedia.org/wiki/Command-line_interface#Command-line_option">exam 60 - Command line Flags</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Environment_variable">exam 61 - Environment Variables</a></li>
  <li><a href="http://pygments.org/">exam 62 - pygments.org</a></li>
  <li><a href="https://github.com/mmcgrana/gobyexample/blob/master/tools/generate.go">exam 62 - generator.go</a></li>
  <li><a href="https://gobyexample.com/spawning-processes">exam 63 - Spawning_Process</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Exec_(system_call)">exam 63 - exec(system call)</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Unix_signal">exam 64 - signals</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) Go 언어를.arabojja - 1</title>
	  <link>//Study-go-1</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-20T00:00:00+09:00</pubDate>
	  <guid>//Study-go-1</guid>
	  <description><![CDATA[
	     <p>[데이터공작소] 일단 시작하기 앞서서 설치를 먼저 해봅시다.</p>

<h2 id="section">설치</h2>
<p>Go Compiler는 공식 웹페이지 에서 다운 받을 수 있다.  버전은 1.8.1</p>

<ol>
  <li>플랫폼별 인스톨 파일
    <ul>
      <li><a href="https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz">Linux 다운로드</a></li>
      <li><a href="https://storage.googleapis.com/golang/go1.8.1.darwin-amd64.pkg">MacOS 다운로드</a></li>
      <li><a href="https://storage.googleapis.com/golang/go1.8.1.windows-amd64.msi">Windows 다운로드</a></li>
    </ul>
  </li>
  <li>환경변수 및 PATH 설정[<a href="https://golang.org/doc/install?download=go1.8.1.linux-amd64.tar.gz">참고페이지</a>]</li>
</ol>

<p>``` sh</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ sudo tar -C /usr/local -xzf go1.8.1.linux-amd64.tar.gz 
$ vi ~/.zshrc

# ----------- vi ~/.zshrc -------------------------------
GOROOT=/usr/local/go
PATH=$PATH:$GO_HOME/bin:$GOROOT/bin

export PATH GOROOT
# ------------------------------------------------------   ```
</code></pre>
</div>

<h4 id="vi-bashrc--">vi ~/.bashrc 파일 설정</h4>

<p><img src="/assets/images/post/2017-05-20/bash.png" alt="vi .bashrc.sh" /></p>

<ol>
  <li>Source 편집</li>
</ol>

<p>``` go</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ vi {CUSTOM\_PROJECT\_HOME}/src/hello/hello.go  
----------------
package main 
import "fmt"

func main(){
    fmt.Printf("Hello world\n")
}
---------------
$ cd {CUSTOM\_PROJECT\_HOME}/src/hello
$ go build 
</code></pre>
</div>

<p>```</p>

<h4 id="vi-bashrc---1">vi ~/.bashrc 파일 설정</h4>

<p><img src="/assets/images/post/2017-05-20/hello.go.png" alt="vi hello.go" /></p>

<h4 id="section-1">소스 실행 결과</h4>

<p><img src="/assets/images/post/2017-05-20/hello-result.png" alt="result hello.go" /></p>

<h4 id="go---">설치된 Go 의 환경설정 확인</h4>

<p><img src="/assets/images/post/2017-05-20/env.png" alt="go env" /></p>

<p>여기 과정까지 무사히 왔다면 설치는 완료</p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) Go 언어를.arabogga - Intro</title>
	  <link>//Study-go-intro</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-19T00:00:00+09:00</pubDate>
	  <guid>//Study-go-intro</guid>
	  <description><![CDATA[
	     <p>[데이터공작소] Go언어에 대해 알아볼까요 ?</p>

<h5 id="section">이 언어를 시작하게 된 동기</h5>
<p>Retrica 면접을 보는대 Retrica 서버는 Go 언어와 ProtoBuf를 활용한 서버를 사용중이었다. 
면접 질문중에서 ..</p>

<blockquote>
  <p>면접관 질문 : 용진씨가 해본 언어 Java, Javascript, Python 위 셋 중에 어떤언어가 
철학적으로 마음에 들며, 어떤 언어를 배우고 싶으신가요?</p>
</blockquote>

<p>사실 Retrica에 들어가기 전부터 Go와 Erlang를 배우고 싶어했었다. 하지만, 취업을 해야하는 입장에서
뭐가 하고 싶다 하더라도 쉽게 도전할 깡다구가 생기지 않는다. 영어하랴, 자소서쓰랴 등등.. 
여러가지 요인이 날 방해하고있었기 때문이다. 답변은 속 시원하게 말아먹었었다.</p>

<blockquote>
  <p>내 답변 : “철학으로는 Javascript고 배우고 싶은 언어는 Go와 Erlang입니다. 
Javascript의 … (나도 정확히 모르는 내용을 예시를 들려고해서 아예 이 답변을 말아먹었다. ) 
그리고 Go 와 Erlang 은 배우고 싶은대 그 이유는 분산처리에 탁월하다는 능력을 들었었습니다. 
직접 해본적은 없지만 만약 배운다면 Go또는 Erlang을 배우고 싶었습니다. 
Erlang은 네이버 라인에서 사용하고 있는 언어로 동접자가 기하급수로 불어난 서비스에 어떻게 해서 
Erlang으로 구축할 생각을 했었는지 어떤 의사결정을 통해 Erlang을 선택했는지 궁금했습니다..(생략)”</p>
</blockquote>

<p>아직 결과는 나오지 않았지만 분명 탈락일것이다. 
내가 면접관이라도 모르는 내용으로 답변하려 들면 기분좋게 탈락시켰을 태니 말이다.</p>

<blockquote>
  <p>즉, 지금은 이 언어를 시작하게 된 동기는 원래 배우고 싶었지만 결정적인 원인은
실제로 해보고 싶었으면서 면접에서 탈탈 털린 내 자신에게 한탄하기위해 시작한다.</p>
</blockquote>

<hr />
<p>Retrica에서 면접보러온사람이 서버개발자 팀장급과 Retrica 를 처음 만든 창업자 장본인(CEO)이 와서
면접을 보았다. 난 이것에 탈락되어도 후회하지않는다. ( 아쉽긴 하지만 ) 심지어 싸인도 받아보고 싶다.</p>

<h2 id="intro">Intro</h2>
<p>불순한 동기로 시작한 언어지만 자세히 알아보도록 합니다.</p>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개발자</td>
      <td>로버트 그리즈머, 롭 파이크, 켄 톰슨</td>
    </tr>
    <tr>
      <td>공식 홈페이지</td>
      <td><a href="http://golang.org">http://golang.org</a></td>
    </tr>
    <tr>
      <td>개발 회사</td>
      <td>Google 갓 구글 차냥해!</td>
    </tr>
    <tr>
      <td>라이센스</td>
      <td>BSD</td>
    </tr>
  </tbody>
</table>

<h4 id="go---">시작하기전에 Go 뽕 맞고 시작하자.</h4>

<iframe width="560" height="315" src="https://www.youtube.com/embed/LJvEIjRBSDA" frameborder="0" allowfullscreen=""></iframe>

<blockquote>
  <p>Write in Go(Lyrics)
The schedule’s tight on the cluster tonight
분산환경에서 해야 할 일로 쉴 틈 없을 오늘밤</p>

  <p>So I parallelized my code
그래서 저는 병렬화된 코드를 작성했지요</p>

  <p>All those threads and continuations
그 모든 스레드와 연속성들로</p>

  <p>My head’s going to explode
제 머리는 폭발하기 일보직전이랍니다</p>

  <p>And all that boilerplate
심지어 그 모든 의례적인 코드들</p>

  <p>That FactoryBuilderAdapterDelegateImpl
그 모든 “괴상야릇한디자인패턴의복잡다단한구현의향연”</p>

  <p>Seems unjustified
이건 제가 가야 할 길이 아닌 것만 같아요</p>

  <p>Give me something simple
좀 더 간결한 길을 알려주시겠어요?</p>

  <p>Don’t write in Scheme
스킴 쓰지 마세요</p>

  <p>Don’t write in C 
C로 짜지 마세요</p>

  <p>No more pointers that I forget to free() 
해제하길 깜빡한 포인터여 이제 그만 안녕</p>

  <p>Java’s verbose, Python’s too slow 
Java는 번잡하고, 파이썬은 느려터졌단 걸</p>

  <p>It’s time you know
이제 깨달을 때가 왔어요</p>

  <p>Write in Go! Write in Go! 
Go로 짜세요, Go로 짜세요!</p>

  <p>No inheritance anymore
클래스 상속이여 이제 그만 안녕</p>

  <p>Write in Go! Write in Go! 
Go로 짜세요, Go로 짜세요!</p>

  <p>There’s no do or while, just for 
do도 while도 없어, for뿐</p>

  <p>I don’t care what your linters say
당신의 linter가 뭐라 불평하든 상관없어요</p>

  <p>I’ve got tools for that
제겐 해결책이 있답니다</p>

  <p>The code never bothered me anyway
코드 자체가 신경 쓸 일을 만들지 않을테니 말이죠</p>
</blockquote>

<h2 id="go-">Go언어의 활약</h2>
<ul>
  <li>Docker를 만든 언어 go !</li>
  <li>드롭박스</li>
  <li>클라우드 플레어</li>
  <li>사운드클라우드</li>
  <li>넷플릭스</li>
  <li>트위치</li>
  <li>뉴욕타임즈 Gizmo API</li>
  <li>SpaceX 원격측정 프로그램</li>
</ul>

<h2 id="section-1">배경지식</h2>
<p>전반적으로 C에서 영향을 많이 받았으며, 철학으로는 단순함을 목표로 한다.
나온 지 5년 동안은 구글에 취직이라도 하지 않는 이상 배워봤자 딱히 쓸 데가 없다는 이유로 새로운 언어에 관심이 많은 덕후얼리어답터 개발자들 사이에서나 알음알음 쓰이던 정도였지만
Go 언어 사용자들을 Gopher라 부르며, Gopher 들을 위해 매년 <a href="https://www.gophercon.com/">고퍼콘(Gophercon)</a>이 열리긴한다.(Gophercon Korea 는 가끔 인 것 같은 것…? ) 
많은 종류의 프로그램 버그는 프로그래밍 언어 차원에서 원천적으로 차단될 수 있으며, 
프로그래밍 언어 연구자들은 쓰기 쉬우면서도 최대한 많은 버그를 컴파일 시점에 잡을 수 있는 타입 시스템을 만드는데 많은 노력을 기울이고 있다.</p>

<ul>
  <li>2009년 11월에 처음 나옴,</li>
  <li>2014년 12월에 1.4 버전</li>
  <li>2015년 8월에 1.5 버전
    <ul>
      <li>1.5 버전에서는 드디어 Go 컴파일러가 Go로 작성되었다.</li>
      <li>그 이전까지는 C언어로 작성.</li>
      <li>자기 자신으로 구현된 컴파일러가 생겼다는 것은 개발 속도에 상당한 가속이 붙게 되었다는 의미가 될 수 있다.[4]</li>
    </ul>
  </li>
  <li>2016년 2월에는 HTTP/2가 기본으로 지원되고 템플릿 문법의 개선 등이 이루어진 1.6 버전이 릴리즈되었다</li>
  <li>2016년 8월에는 컴파일 속도의 개선, 실행 퍼포먼스 향상, /x/net/context 패키지의 기본 패키지화 등이 이루어진 1.7 버전이 릴리즈되었다.</li>
</ul>

<h4 id="section-2">(릴리즈 특징)</h4>
<ul>
  <li>여전히 1.4 버전에 비해 컴파일 속도는 느림(Go Compiler 를 사용하고 나서..)</li>
  <li>2018년 2월에 32비트 MIPS 명령어 지원, 컴파일러 프론트 엔드 추가, 가비지 컬렉션 개선, Cgo의 오버 헤드 개선 등의 변경점이 있는 1.8 버전이 출시</li>
</ul>

<h4 id="go--">Go 언어의 특징</h4>
<ul>
  <li>Go 언어를 이용해서 안드로이드와 iOS 앱을 제작할 수 있게 적용 중이다.</li>
  <li>웹 개발에도 쓰이고 있고 특히 서버 사이드 언어로서 좋은 평가를 받고 있다.</li>
  <li>Go가 자체적으로 지원하는 라이브러리만으로도 간결하게 웹사이트를 만들어낼 수 있다.</li>
  <li>Go 언어의 특징은 컴파일 언어이지만 컴파일러의 컴파일 속도가 매우 빨라 인터프리터 언어처럼 쓸 수 있다는 점에 있다.
언어의 문법 구조를 개선함으로써 달성하였다. 컴파일러가 소스 코드를 해석하는 pass 수를 줄여서 달성한 것으로 보인다.</li>
  <li>접근하기 어렵지 않고, 코드 역시 간결하면서도 컴파일 언어답게 높은 성능을 낼 수 있다는 점이 호평을 받는다.</li>
  <li>간결하게 코드를 작성할 수 있으면서도 풍부한 라이브러리 등의 덕택에 막강한 기능을 쉽게 구현할 수 있다는 것은 큰 장점이다.</li>
  <li>그러나 컴파일 언어의 태생적인 한계를 극복한 것은 아니라서 대형 모듈을 이것저것 붙이면 컴파일에 필요한 시간이 있기에 Python 등의 인터프리터 언어보다는 기동할 때에 확실히 반응이 늦다.</li>
  <li>물론 컴파일 언어 중에서는 매우 빠른 편이지만 아무래도 인터프리터 언어의 즉흥성까지 바라는 건 무리. 물론 컴파일 언어인만큼 실행 시 퍼포먼스는 확실하다.</li>
</ul>

<h4 id="go---1">Go 루틴에 대해</h4>
<p>Go는 GoRoutine이라는 비동기 메커니즘을 제공한다. 이 비동기 메커니즘은 <em>Erlang</em>에서 영향을 받은 것으로 각각의 고루틴은 병렬로 동작하며 메시지 채널을 통해 값을 주고받는다.<br />
고루틴을 사용하면 이벤트 처리, 병렬 프로그래밍 등이 간단해진다. 단 병렬화된 고루틴의 동기화 문제는 프로그래머가 챙겨 줘야 하며 동기화를 무시할 경우 프로그램이 비정상 종료할 수도 있다.</p>

<p>예를 들어 부모 루틴이 자식 루틴보다 먼저 끝나버리면 자식 루틴은 OS에 의해 메모리에서 강제로 사출되어 버린다. 
단 동기화 방법은 기존 멀티스레드 응용프로그램에 비해 매우 간단한 편. 단순히 고루틴으로부터 반환값을 받는 줄을 메인 스레드에 추가하면 된다. 
고루틴은 멀티스레드 메커니즘이지만 자체적인 스케줄러에 의해 관리되는 경량 스레드이며 OS에서 관리하는 경량스레드보다 더 경량이다. 
따라서 고루틴은 CPU 코어수와 무관하게 수백 수천만 고루틴을 작성해도 성능에 문제가 생기지 않는다. 
이는 Erlang도 마찬가지. Go는 바이너리 컴파일러이므로 서로 다른 머신 플랫폼들을 타겟으로 배포해야 할 경우 
환경변수(GOOS와 GOARCH 등)를 그에 맞게 설정한 후 컴파일해서 여러 벌의 배포판을 만들어야 한다.</p>

<h2 id="go---2">Go의 비판적 시각</h2>

<p>컴파일 언어인 덕분에, 속도가 느린 스크립트 언어에서 연산 퍼포먼스가 필요한 부분을 Go로 대체해 넣을 수도 있다. 
예를 들면, Go로 만든 코드를 공유 라이브러리로 컴파일해 Ruby에서 FFI를 이용해 컴파일한 .so 파일을 가져와 사용하는 식. 
PHP에서도 역시 가능하다. 다만 기본 패키지들 중에서는 성능보다는 편의성에 초점을 맞춘 탓에 극한의 성능을 추구하는 경우라면 사용을 권하기 어려운 것들이 있다. 
예를 들면 웹 서버 제작시에 쓰이는 net/http나 html/template 등이 그러한데, 
이런 경우엔 기본 패키지를 대체하는 별도의 패키지를 이용하면 (실제 체감효과는 별론으로 하되 벤치마크상으로는 심지어 수십 배나 수치가 좋아지는(…) 경우도 있다.</p>

<ul>
  <li>Go 언어의 설계 지향점이 시스템 프로그래밍 언어이었으나 가비지 컬렉션의 지원이나 제네릭의 부재로 인해 박싱/언박싱이 불필요하게 많이 일어나는 등(시스템프로그램 CLI환경에서 구동하는 녀석으로 시스템콜이 빈번한 프로그래밍이 되어야 하는대 박싱/언박싱의 불필요한 호출로 시스템프로그래밍언어로 적합한가에 대한 의구심이 생기는 추세)</li>
  <li><strong>C/C++을 대체할 수 있는 언어는 아니라는 것</strong> 에 합의가 이루어지고 있는 상황이다.</li>
  <li>실제로 고성능 연산에 사용하기에는 C/C++에 비해 <strong>너무 느리며</strong>,</li>
  <li>저수준 시스템 개발에서는 가비지 컬렉션과 고루틴을 지원하기 위한 <strong>무거운 런타임</strong> 등으로 인해 사용이 불가능에 가깝다.</li>
  <li>대체로 개발 속도와 실행 속도, 병행성 사이의 적정 지점이 필요한 서버 애플리케이션 개발 등에 많이 사용되는 편.</li>
  <li>이전 버젼에서는 저수준 시스템 프로그래밍에서도 C/C++보다 낫다는 식의 서술이 있었으나, 이는 <strong>go를 개발하던 당시 개발진의 목표였을 뿐</strong></li>
  <li>현대 프로그래밍 언어 연구의 성과를 일체 무시한 언어 설계.</li>
  <li><strong>널 포인터</strong>나 <strong>안전하지 않은 타입 캐스팅</strong>을 장려하는 인터페이스</li>
  <li>타입 안전한 제네릭의 부재</li>
</ul>

<h2 id="section-3">유용한 참고 사이트</h2>
<ul>
  <li><a href="http://codingnuri.com/golang-book/">무료 E-Book : condingnuri.com/golang-book</a></li>
  <li><a href="https://plus.google.com/communities/115721275599816202991">Gopher Korea</a></li>
  <li><a href="http://pyrasis.com/go.html">pyrasis.com 의 빠르게 만나는 Go</a></li>
  <li><a href="https://golangkorea.github.io">golangkorea.github.io</a></li>
  <li><a href="https://github.com/arahansa/golkorea">아라한사씨의 깃헙</a></li>
  <li><a href="https://go-tour-kr.appspot.com/#1">https://go-tour-kr.appstop.com/#1</a></li>
</ul>

<h2 id="section-4">과제</h2>
<ol>
  <li>언어 자체가 가진 매력? 패러다임? 차이점은 무엇인가?</li>
</ol>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 하둡.araboza - 6</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-6</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-08T09:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-6</guid>
	  <description><![CDATA[
	     <p>[데이터공작소] 하둡의 WordCount 예제가 아닌 약간의 응용을 해보는 예제를 체험합니다.</p>

<h2 id="section">소스 위치</h2>
<ul>
  <li><img src="https://github.com/drake-jin/hadoop-study/tree/master/week06" alt="Chapter06의 소스코드" /></li>
  <li>이클립스에서 작업하였고 실행하기위해서는 maven project import 기능을 사용해 주세요.</li>
</ul>

<h2 id="chapter-06">Chapter 06</h2>
<ul>
  <li>본 챕터는 소스 코드를 참고하면서 이용해주시기 바랍니다.</li>
  <li>소스코드의 설명은 주석으로 달아놓았습니다.</li>
</ul>

<h2 id="section-1">위키피디아</h2>
<ul>
  <li>위키피디아는 집단지성의 정보를 대표로하는 서비스로써 사용자들의 참여가 우선시 되는 서비스이다.  위키피디아를 크롤링하거나 스크랩핑하는곳이 많아서 그냥 데이터베이스를 덤프로 제공하기도 한다.</li>
  <li><img src="http://download.freebase.com/wex/2012-07-01/freebase-wex-2012-07-0-articles.tsv.bz2" alt="위키피디아 가공 문서" /></li>
</ul>

<h2 id="section-2">프리베이스</h2>
<ul>
  <li><img src="http://download.freebase.com/wex/" alt="프리베이스" /></li>
  <li>프리베이스는 자신의 커뮤니티의 구성원들이 업로드한 데이터들로 구성된 대규모 지식 베이스(온라인에 최적화된 Data들)</li>
  <li>음악,TV, 영화, 인물, 회사,책 영문버전으로 존재함</li>
</ul>

<h2 id="section-3">트러블 슈팅</h2>
<ul>
  <li>hdfs의 파일을 /tmp에 저장했을 경우 리부팅을 할 경우에</li>
</ul>

<h3 id="section-4">구현할 프로그램</h3>

<table>
  <thead>
    <tr>
      <th>예제프로그램</th>
      <th>기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WordCount2</td>
      <td>기존 WordCount를 개량한것</td>
    </tr>
    <tr>
      <td>TopN</td>
      <td>빈도수 기준으로 최대의 N개의 레코드들을 뽑는다.</td>
    </tr>
    <tr>
      <td>CountTrigram</td>
      <td>트라이그램별로 빈도수를 계산하고 바로 TopN을 실행하여 빈도수가 높은 트라이그램을 보여줍니다.</td>
    </tr>
    <tr>
      <td>CountCitation</td>
      <td>200만개의 영문 위키피디아 문서들에 대해서 각기 인용된 숫자를 보여준다. WordCount와 흡사하다.</td>
    </tr>
    <tr>
      <td>JoinIDTitle</td>
      <td>CountCitation의 결과에 TopN을 적용하여 가장 많이 인용된 문서 10개의 문서를 알아낸 후에 JoinIDTitle을 이용해서 그 문서들의 타이틀을 알아낼 수 있다.</td>
    </tr>
  </tbody>
</table>

<h1 id="wordcount2">WordCount2</h1>
<ul>
  <li>WordCount와 WordCount2는 3가지가 개선되었다.
    <ol>
      <li>데이터의 크기가 다르다.</li>
      <li>문서형식은 문서 ID와 ID에 대한 텍스트가 들어가는 형태</li>
      <li>키는 ID 밸류는 텍스트, 프로그램의 입력포맷은 KeyValueTextInputFormat 이다.</li>
      <li>WordCount 프로그램은 컴바이너의 특성을 이용한다.</li>
      <li>전체단어를 카운트 해서 볼 수 있다.</li>
    </ol>
  </li>
</ul>

<h1 id="topn">TopN</h1>
<ul>
  <li>WordCount2에서는 나타나는 모든 단어의 빈도수가 계산되기 때문에 만일 빈도수가 가장 높은 10개를 알고싶다면 다시 한번 별도로 처리해야한다.</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 하둡.araboza - 5</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-5</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-08T09:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-5</guid>
	  <description><![CDATA[
	     <p>[데이터공작소]하둡.araboza - 5 에서 진행했던 소스를 좀 더 자세히 살펴보는 글입니다. 이번 챕터를 통해 맵 리듀스에 대해 자세히 알아보는 시간을 갖도록 합니다.</p>

<h2 id="chapter-05">Chapter 05</h2>
<p>Chapter04의 WordCount소스에 사용된 MapReduce소스에 대해서 분석해보는 챕터입니다.
 - <a href="https://autofei.wordpress.com/2010/06/27/oreilly-hadoop-the-definitive-guide-06-2009">하둡의 작동방법에 대해 상세히 나와있음 </a></p>

<p><img src="/assets/images/post/2017-05-08/mapreduce.jpg" alt="mapreduce" />
<img src="/assets/images/post/2017-05-08/mapreduce-process.png" alt="mapreduce-process" /></p>

<h2 id="section">차례</h2>
<ol>
  <li>맵퍼</li>
  <li>맵리듀스의 기본 자료형</li>
  <li>입력포맷</li>
  <li>컴바이너</li>
  <li>셔플링과 소팅</li>
  <li>리듀스</li>
  <li>출력포맷</li>
  <li>카운터</li>
  <li>MRUnit과 메이븐</li>
  <li>잡 트래커와 웹 인터페이스</li>
</ol>

<h2 id="section-1">맵 리듀스의 맵퍼</h2>

<p>``` java
class Mapper{</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void setup(Mapper.Context context);
/*
map 메소드에서 필요 리소스를 할당하는 역할을 합니다. map의 선행작업을 여기서 수행할 수 있습니다.
분산캐시를 오픈하거나 파일을 미리오픈하거나 여기서 할 수 있습니다.
*/    

public void cleanup(Mapper.Context context);
/*
setup클래스의 반대 역할입니다. 할당한 리소스를 해제하는 역할을 합니다. 함수의 호출이 완료되면, 마지막으로 한번 호출됩니다.
예를들어 setup에서 할당한 자원을 cleanup에서 해제하는것이 일반적인 사용모델입니다.
*/

public void run(Context context) throws IOException InterruptedException{
    setup(context);
    while(context.nextKeyValue()){
        map(context.getCurrentKey(), context.getCurrentValue(),context)
    }
    cleanup(context);
}
/*
Mapper의 전체 구동함수에 해당하며 이 함수를 오버라이드 할 일은 거의 없을것이다.
setup메서드의 작업이 끝나야지 run메서드가 수행된다.
*/
</code></pre>
</div>

<p>}
```</p>

<h3 id="k1v1">맵퍼의 입력 K1,V1</h3>
<p>맵의 입력에서 가장 중요한 부분은 어떤 입력 포맷을 사용하였는가이다.
 - 텍스트 라인 하나가 하나의 레코드에 해당
 - 해당 라인의 파일오프셋(파일 처음부터의 위치)가 키 값이 된다. (키 타입은 LongWritable)
 - 해당 라인의 전체가 Value가 됩니다. Value Type은 Text가 됩니다.
맵의 입력에 사용되는 입력포맷은  TextInputFormat 이외에도 [KeyValueTextInputFormat, SequenceFileInputFormat]등이 있습니다.</p>

<h3 id="k3v3">맵퍼의 출력 K3,V3</h3>
<p>맵의 출력 레코드들의 타입들이 전체 하둡 잡의 출력 타입들과 다르다면 Job클래스의 다음 두 메서드 호출을 통해서 프레임 워크에 알려야 합니다.</p>

<blockquote>
  <p>job.setMapOutputKeyClass
  job.setMapOutputValueClass</p>
</blockquote>

<p>워드카운트 에서는 맵의 출력타입과 리듀스의 출력타입이 일치했기 때문에 위의 두 메소드를 호출할 필요기 없었습니다.</p>

<p>간혹 맵 출력만 필요하고 리듀스는 아예 필요로 하지 않는다면 리듀스 태스크의 수를 0으로 지정하면 된다. 그러면 지정한 하둡잡의 출력 디렉토리에
맵의 출력물들이 바로 저장되게 된다.</p>

<blockquote>
  <p>저장되는 파일 이름 형식은
part-r-xxxx =&gt; part-m-xxxx가 된다.</p>
</blockquote>

<h3 id="identity-mapper--reducer">아이덴티티 맵퍼,리듀서 (Identity Mapper &amp; Reducer)</h3>
<p>작업중에는 맵이나 리듀스가 필요없는것들도 있다. 이럴 때 사용하는게 아이덴티티 맵퍼나 리듀서이다.
&gt; 아이덴티티 매퍼와 아이덴티티 리듀서는 주어진 입력 레코드(키,벨류)를 그대로 출력레코드로 내보내는 단순한 맵 클래스와 리듀스 클래스.</p>

<h2 id="mapreduce----">MapReduce의 기본 자료형 및 변수들</h2>

<p><img src="/assets/images/post/2017-05-08/wrapping-variables.png" alt="wrapping variables" /></p>

<h3 id="writable-">Writable 인터페이스</h3>
<ul>
  <li>기본적으로 이 인터페이스는 직렬화/역직렬화(Serialization/Deserialization) 을 구현하는데 사용되는 메소드들을 갖고 있다.</li>
  <li>하둡 특성상 키/벨류 레코드가 디스크에 저장되거나 네트워크를 타고 전달되어야 하기 때문에 이런 인터페이스가 필요하다.</li>
  <li>하둡은 RPC(Remote Procedure Call)을 이용해서 클러스터 내의 노드들 간에 통신합니다. 이 경우에도 Writable인터페이스를 사용하여 통신합니다.</li>
</ul>

<p>``` java 
public class ItemFreq implements Writable{
    private String item;
    private Long freq;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public void write(DataOutput out)throws IOException{
    //write는 직렬화(Serialization)에 사용되는 메서드 이다. 주어진 스트림 내부 데이터를 차례로 저장하는 일을 수행하며, 저장된 데이터들만 보고 원래 상태가 복구될 수 있게 필요한 모든 정보를 저장한다.
    WritableUtils.wrtieString(out, item);
    // 먼저out객체에 item을 작성하고
    out.writeLong(freq);
    // 그 다음 out 객체에 값을 작성한다.
}
@Override
public void readFields(DataInput in) throws IOException{
    // readFields 는 역직렬화(Deserialization)에 사용되는 메서드 이다. write에서 저장했던 순서 ㄱ대로 차례로 저장했던 데이터를 꺼내어 객체의 마지막 상태로 원상 복구하는 역할을 수행한다.
    item = WritableUtils.readString(in);//in의 item문자열을 읽는다.
    freq = in.readLong(); // freq를 읽는다.
}
//... 생략
</code></pre>
</div>

<p>}
```</p>

<h3 id="writablecomparable-">WritableComparable 인터페이스</h3>
<ul>
  <li>WritableComparable 은 Writable 에서 제공되는 메소드들에다가 객체들간의 비교를 가능하게 해주기 위해 Comparable인터페이스가 추가된 인터페이스 입니다.</li>
  <li>하둡에서 맵과 리듀스에서 사용되는 키들은 소팅이 가능해야 하기 때문에 이런 인터페이스가 필요합니다.</li>
  <li>Compareble인터페이스에는 compareTo라는 메소드 하나가 존재하며 이는 결국지금 객체와 인자로 들어온 객체들을 비교하여 둘 사이의 순서를 정해주는 역할을 합니다.</li>
</ul>

<p>``` java
 // Writable인터페이스에서 compareTo 메서드가 추가된것 말고 다른게 없음.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public int compareTo(ItemFreq o) {
    int result = item.compareTo(o.item);
    if(0 = result){
        result = (int) (freq-(o.freq));
    }
    return result;
}
</code></pre>
</div>

<p>```</p>

<h2 id="mapreduce-wapping-">MapReduce의 Wapping 자료형</h2>

<table>
  <thead>
    <tr>
      <th>Wrapping 변수</th>
      <th>원본</th>
      <th>반환 방법</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Text</td>
      <td>String</td>
      <td>.toString()</td>
    </tr>
    <tr>
      <td>IntWritable</td>
      <td>int</td>
      <td>.get()</td>
    </tr>
    <tr>
      <td>LongWritable</td>
      <td>Long, long</td>
      <td>.get()</td>
    </tr>
    <tr>
      <td>FloatWrtiable</td>
      <td>Floa, float</td>
      <td>.get()</td>
    </tr>
    <tr>
      <td>BooleanWritable</td>
      <td>Boolean, boolean</td>
      <td>.get()</td>
    </tr>
    <tr>
      <td>ArrayWritable</td>
      <td>[] , ArrayList</td>
      <td>x</td>
    </tr>
    <tr>
      <td>NullWritable</td>
      <td>null</td>
      <td>x</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>이외 제공되는 타입을 보려면 http://org.apache.hadoop.io를 참조하길…</li>
</ul>

<h2 id="section-2">입력 포맷의 역할</h2>
<p><img src="/assets/images/post/2017-05-08/input-format.png" alt="input format " />
 - job.setInputFormatClass() 에 해당되는 내용.</p>

<h3 id="textinputformat">TextInputFormat</h3>
<ul>
  <li>FileInutFormat을 상속함</li>
  <li>텍스트 파일 대상이며 .gz 로 압축된 것도 처리가능하다.</li>
  <li>라인 하나(\n, \r)가 하나의 입력 레코드에 해당됨.</li>
  <li>한 레코드(라인)에서 키는 라인의 파일 오프셋(파일 선부에서부터) 타입은LongWritable이다.</li>
  <li>한 레코드에서 라인 전체 스트링이 되며 타입은 text이다.</li>
</ul>

<h3 id="keyvaluetextinputformat">KeyValueTextInputFormat</h3>
<ul>
  <li>Keyvaluetextinputformat = TextInputFormat 기본적으로는 같다.</li>
  <li>차이점은 하나의 레코드를 해석할 때 키와 벨류사이에 TAB문자와 같은 문자열을 분리자로 인지 하는지 안하는지에 대한 차이가 있습니다.</li>
  <li>TAB 문자열 = \r</li>
</ul>

<h3 id="sequencefileinputformat">SequenceFileInputFormat</h3>
<ul>
  <li>하둡의 고유 파일 폼냇은 시퀀스파일</li>
  <li>이 때 사용되는 기본 클래스가 바로 이 클래스</li>
  <li>해당 파일이 생성 될 때 사용된 키와 밸류 타입을 사용해야 한다.</li>
  <li>하지만 TextInputFormat 과 다른점은 LongWritable 과 Text로 고정된것이 아니기 때문에 어떤 Key와 Value로써 사용가능합니다.</li>
  <li>이 포맷은 맵 파일을 읽는데도 사용할 수 있습니다.</li>
  <li>디렉토리로 값을 줘도 읽을 수 있으며, 디렉토리로 값을 줄 때 맵 파일의 형태를 먼저 읽고 그 다음에 시퀀스 파일을 로드 합니다.</li>
</ul>

<h3 id="multipleinputs">MultipleInputs</h3>
<ul>
  <li>지금까지 입력포맷은 잡에 하나의 맵만 존재하는 형태였다. 하지만 입력포맷이 다른 경우에는 어떻게 되는가?</li>
  <li>Multipleinputs클래스를 사용하여 공통된 키를 묶어서 조인을 수행할 수 있다.</li>
</ul>

<p>``` java
    public static void addInputPath(
        JobConf conf,  // 별도의 job class파일을 이용해도 된다. 
        Path path, //hdfs상의 파일 위치
        Class&lt;? extends InputFormat&gt; inputFormatClass,
        Class&lt;? extneds Mapper&gt; mapperClass
    )</p>

<p>```</p>

<h3 id="section-3">그 외 입력폼맷</h3>
<ul>
  <li>CombineFileInputFormat</li>
  <li>NLineInputFormat</li>
</ul>

<h3 id="section-4">맵 태스크 수의 결정 방식</h3>
<ul>
  <li>입력파일을 처리하기 위해 필요한 맵 태스크의 수는 프레임워크가 알아서 결정한다.</li>
  <li>입력포맷이 주어진 입력 파일을 처리하는데 몇 개의 맵 태스크가 필요한지 결헝한다.</li>
  <li>입력포맷은 getSplits라는 메소드를 갖고 있는데 이는 주어진 모든 입력 파일들을 조각(InputSplit이라 한다.)으로 나눠서 그 조각들의 리스트를 리턴합니다.</li>
  <li>이 조각마다 맵 태스크가 하나씩 할당된다.</li>
</ul>

<ol>
  <li>리듀스가 하나일경우</li>
</ol>

<p><img src="/assets/images/post/2017-05-08/one-reduce.png" alt="one reduce" /></p>

<ol>
  <li>리듀스가 두개일 경우</li>
</ol>

<p><img src="/assets/images/post/2017-05-08/two-reduce.png" alt="two reduce" /></p>

<ol>
  <li>리듀스가 없을 경우</li>
</ol>

<p><img src="/assets/images/post/2017-05-08/none-reduce.png" alt="none reduce" /></p>

<h3 id="getsplits----">getSplits의 파일 조각 나누는 방식</h3>

<blockquote>
  <p>(맵 태스크 수) = (입력파일 수) * (데이터블록) or (gzip 등 압축된 파일 수)</p>
</blockquote>

<ol>
  <li>입력파일의 수
    <ul>
      <li>기본적으로 입력 파일의 수가 중요한 요소가 된다.</li>
      <li>맵 태스크의 수는 이보다 더 작아질 수는 없다.</li>
    </ul>
  </li>
  <li>입력파일의 크기
    <ul>
      <li>데이터 블록으로 구성될 탠대 맵 테스크는 하나의 블록마다 할당된다.</li>
      <li>결국 하나의 블록이 하나의 Input Split이 된다.</li>
    </ul>
  </li>
  <li>입력포맷의 지능
    <ul>
      <li>gzip 등으로 압축되어있으면 전체 파일을 블록수와 관계없이 하나의 맵태스크로 지정함</li>
    </ul>
  </li>
</ol>

<h3 id="section-5">입력포맷의 역할</h3>
<ul>
  <li>입력파일을 InputSplit으로 나누기</li>
  <li>하나의 InputSplit내의 레코드들을 읽는 방법 제공</li>
</ul>

<h2 id="combiner">컴바이너 (Combiner)</h2>
<ul>
  <li>미니 리듀서 혹은 로컬 리듀서라고 부른다.</li>
  <li>맵 태스크의 출력에 리듀스 코드 먼저 적용해서 리듀스로 넘어가야 하는 데이터의 크기를 줄이는 역할 담당.</li>
  <li>컴바이너 적용 가능 모델 :잡의 성격마다 다르지만 작업의 순서를 달리해도 최종 결과물이 같은 잡일 경우에만.</li>
  <li>컴바이넌 적용 가능 모델이라면 리듀스 클래스를 그대로 컴바이너로 가져가는걸 추천한다.</li>
  <li>셔플링과 소팅부분에서는 컴바이너를 여러번 적용 시키는 모델이 존재한다.</li>
  <li>WordCount의 경우 Combiner의 특성을 가지고 있기 때문에 main함수에서 리듀스 클래스를 그대로 컴바이너로 지정할 수 있습니다.</li>
</ul>

<h2 id="shuffling-and-sorting">셔플링과 소팅(Shuffling and Sorting)</h2>
<p>맵 리듀스에서 자동으로 해주는 내부동작이다. 맵 태스크와 리듀스 태스크를 이해하기위해 이해하고 넘어가야 할 부분</p>

<h3 id="to----">파티셔너 to 레코드 어떻게 리듀스로 보내는가.</h3>
<ol>
  <li>결과 레코드의 키값을 해싱한다.</li>
  <li>해싱된 값을 리듀스 태스크의 수로 나눈다.</li>
  <li>해싱된 레코드가 어느 태스크로 갈지 결졍된다.(같은 키를 갖는 레코드들은 같은 리듀스 태스크로 보내지게 된다.)</li>
  <li>1번~3번 동작을 수행하는것이 바로 파티셔너(partitioner)라 부른다.
    <ul>
      <li>맵 태스크가 새로운 Key/Value를 출력하면 이는 궁극적으로 특정 리듀스 태스크로 보내져야 한다.</li>
      <li>자신만의 파티셔너를 정의할 수 있지만, 기본적으로 사용되는 파티셔너의 클래스이름은 HashPartitioner</li>
    </ul>
  </li>
</ol>

<p>``` java
// HashPartitioner&lt;K,V&gt;.class</p>

<p>public class HashPartitioner&lt;K, V&gt; extends Partitioner&lt;K, V&gt;{
    /** use {@link Object#hashCode()} to partition. **/ 
    public int getPartition(K key,V value, int numReduceTasks){
        return (key.hashcode() &amp; Integer.MAX_VALUE) % numReduceTasks;//파티션 번호에 해당한다.
    }
}</p>

<p>```</p>

<ul>
  <li>파티션 번호 : 위 코드를 보면 알 수 있듯이 주어진 키의 해시값을 얻어낸 다음에 그것을 리듀스 태스크의 수(Job 클래스의 numReduceTasks메소드로 지정한 값)로 나눈 나머지를 리턴하고 있다.</li>
  <li>파티셔너는 맵 테스크에서 나온 ㅊㄹ력레코드를 보고 어느 리듀스 태스크로 보낼지 결정해주는것이 파티셔너 입니다.</li>
</ul>

<h3 id="section-6">맵 출력 버퍼링</h3>
<ol>
  <li>맵에서 출력된 레코드 들은 파티셔너(Partitioner) 클래스를 통해 파티션 번호를 알아낸다.</li>
  <li>리듀스로 바로 가지 않고 메모리 버퍼에 씌어졌다가 메모리 버퍼가 차면 디스크에 레코드가 써집니다.</li>
  <li>맵 태스크가 종료될때까지 1번과 2번 과정을 반복합니다.</li>
  <li>종료시에는 디스크로 존재하던 파일들을 모두 모아서 하나의 파일로 병합합니다.(4번의 과정은 모든 맵 태스크마다 이루어지게 됩니다.)</li>
  <li>리듀스 태스크들은 병합된 결과 레코드 파일에서 각기 자신에게 해당하는 파티션의 데이터를 읽어 갑니다.</li>
  <li>M개의 맵퍼와 N개의 리듀서가 존재한다면 M*N개의 네트워크 커넥션이 맺어지게 됩니다.</li>
  <li>M*N개의 커넥션의 네트워크를 통해 리듀서 자신에게 해당되는 데이터를 복사해 갑니다.</li>
</ol>

<ul>
  <li>M*N개의 커넥션에서 리듀서 자신에게 해당되는 데이터를 복사해갈 때 데이터가 크다면 병목지점이 발생하게 된다.</li>
  <li>성능에 있어 랜덤쓰기와 순차쓰기의 차이때문에 맵의 결과를 임시적으로 메모리 버퍼에 저장하는 방식을 이용한다.  (잦은 파일 입출력 방지를 위해)</li>
</ul>

<h3 id="section-7">셔플링</h3>

<p><img src="/assets/images/post/2017-05-08/shuffling-sorting.png" alt="Shuffling &amp; sorting" /></p>

<ul>
  <li>셔플링 : 맵 태스크가 종료되면 그때 리듀스 태스크들이 자신에게 해당하는 파티션의 데이터만 읽어가게 되는데 이때는 RPC등을 통하는 것이 아니라 그냥 HTTP를 통해 읽습니다. 이 과정을 셔플링이라한다.</li>
  <li>셔플링이 섞는 과정인줄알았는데 알고보니 단순 데이터 복사.</li>
  <li>송수신 시 에러발생을 감지하기위해 CRC(Cycle Redundancy Check)체크썸 정보(4Byte)가 마지막에 별도로 전송된다. 리듀스의 데이터 읽기용말고 일반적으로 데이터 송수신에도 사용된다.</li>
</ul>

<h3 id="section-8">모니터링 툴들</h3>
<ul>
  <li>Ganglia: 하둡전용이 아닌 일반적인 클러스터와 같은 분산화경용 모니터링 시스템</li>
  <li>Amabari : 하둡 클러스터 모니터링, 하둡클러스터 설치와 관리, 여러가지 기능을 지원하는 종합적인 툴의 성격</li>
  <li>Puppet : 환경 설정관리, 파일의 복사 성공여부를 조회하고 관리할 수 있습니다.</li>
</ul>

<h3 id="section-9">소팅</h3>
<ul>
  <li>spill을 합병할 때 처럼 파일들의 수를 이정한 수 밑으로 유지하려 한다. 이 때도 io.sort.factor파라미터 값을 사용한다.</li>
  <li>맵 태스크들에서 자신의 파티션 데이터들을 가져왔으면 이 데이터들을 하나로 병합한다.</li>
  <li>병합된 데이터를 키를 바탕으로 소팅한다.(GroupingComparator)라는 게 이용된다. 이것은 리듀스 태스크들로 모인 레코드들의 키를 정렬하는 역할을 한다.</li>
  <li>소팅이 끝나면 소팅된 레코드들을 전체적으로 스캔하면서 레코드들을 그룹핑한다.</li>
  <li>이는 하나의 리듀스 입력 레코드를 만드는 것이다.</li>
  <li>한 그룹으로 묶여진 레코드들 간의 순서를 정하기 위해서 SortComparator 라는것을 사용한다.</li>
</ul>

<h2 id="section-10">리듀스 클래스</h2>
<ul>
  <li>Reducer클래스를 보면 run, setup, cleanup이란 메소드들을 가지고 있으며 하는 역할도 맵 클래스에서 하는 역할과 비슷하다.</li>
</ul>

<h3 id="section-11">리듀스의 입력</h3>
<ul>
  <li>셔플링과 소팅을 통해 리듀스의 입력은 모든 맵 태크들의 출력 레코드가 합쳐져서 만들어진것.</li>
  <li>맵 태스크 출력 레코드들의 셔플링과 소팅이 완료되면 리듀스의 입력 레코드는 완성됨</li>
</ul>

<h3 id="section-12">리듀스의 출력</h3>
<ul>
  <li>출력레코드는 hdfs상에서 저장된다.</li>
</ul>

<h3 id="identity-reducer">아이덴티티 리듀서(Identity Reducer)</h3>
<ul>
  <li>입력으로 들어온 레코드를 그대로 다시 출력해주는 역할을 한다.</li>
  <li>모든 리듀서의 기본 클래스는 에이덴티티 리듀서로 구현되어있다.</li>
  <li>아이덴티티 리듀서는 밸류 리스트를 다시 리스트로 내보내는것이 아닌 for루프 돌면서 각기 하나의 값을 하나의 레코드로 출력한다.</li>
  <li>밸류 리스트에 N개의 원소가 있었다면, N 개의 키/밸류 레코드를 출력하는 셈</li>
  <li>셔플링과 소팅 때문에 맵 태스크들에서의 원래 출력과 순서가 달라진다.</li>
  <li>대표적으로 같은 키를 갖는 레코드들끼리 모아서 처리해야할 필요가 없는 경우 많이 사용된다.</li>
</ul>

<h3 id="section-13">리듀스 기타</h3>
<ul>
  <li>리듀스에서 주의할 점은  인자로 넘어오는 밸류 리스트 (Iterable<v>)의 경우 한 번 밖에 스캔할 수 없다는 점입니다. 다시 스캔하려고 하면 에러가 발생한다.</v></li>
  <li>그 이유는 reduce메소드에 들어온 입력 레코드들이 메모리에 로드되기전에는 너무 클 수 있기 때문에 내부적으로 한 번만 스캔하도록 되어있다.</li>
  <li>리듀스 테스크를 만약 0으로 정해준다면 맵퍼들의 결과로만 결과가 출력이 되어 결과 파일은 part-m-xxxx로 나오게 될것이다.</li>
</ul>

<h2 id="section-14">출력 포맷</h2>
<p><img src="/assets/images/post/2017-05-08/output-format.png" alt="output format" /></p>

<h3 id="textoutputformat">TextOutputFormat</h3>
<ul>
  <li>한 라인에서 키와 밸류는 tab문자로 구분된다.(KeyValueTextInputFormat)에 반대되는 개념 하지만 그렇다고해서 KeyValueTextOutputFormat이 존재하는건 아니다.</li>
  <li>결과파일 압축하기 job.setCompressOutput과 job.setOutputCompressClass를 사용하여 압축 방법과 여부를 설정할 수 있다.</li>
</ul>

<h3 id="sequencefileoutputformat">SequenceFileOutputFormat</h3>
<ul>
  <li>시퀀스 파일 포맷으로 출력파일을 쓸 때 사용함</li>
  <li>하둡의 여러잡을 이어서 실행할 경우 반드시 사용해야하는 출력포맷이다.</li>
  <li>
    <p>이 출력 포맷은 세 가지 압축 방식(Block, None, Record)를 지원하며 SequenceFileOutputFormat 클래스의 setOutputCompressionType 메소드를 통해 압축방식을 지정할 수 있다.(BLOCK, NONE, RECORD)</p>

    <table>
      <thead>
        <tr>
          <th>압축모드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>BLOCK</td>
          <td>블록내의 레코드들을 같이 압축한다.</td>
        </tr>
        <tr>
          <td>NONE</td>
          <td>압축하지 않는다.</td>
        </tr>
        <tr>
          <td>RECORD</td>
          <td>레코드 별로 압축한다. 기본설정이 바로 레코드별 압축이다.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="mapfileoutputformat">MapFileOutputFormat</h3>
<ul>
  <li>출력을 맵 파일 형태로 만들어주는 출력포맷</li>
  <li>파일 기반의 맵으로 사실상 하나의 디렉토리로 구성되며 그 디렉토리 밑에 두 개의 파일이 존재한다.</li>
</ul>

<blockquote>
  <p>디렉토리 밑의 두 파일에 대한 설명
1. 하나는 맵의 데이터 파일로 모든 키와 벨류들이 들어간다. 키를 바탕으로 정렬된다.
2. 다른 하나는 인덱스 파일로 키들의 일부를 저장하는데 목적은 데이터 파일을 순차적으로 뒤지지 않도록 해주는것.</p>

  <p>순처적으로 뒤지지 않게하는게 왜 ?
- 순차적으로 뒤지지 않게 만들기 위해 키를 일정 간격으로 뽑아 내어서 저장해 둔다. (흔히 스킵테이블이라 한다.)
- 간격을 적당히 크게 하면 인덱스 파일의 크기가 작아지게된다.</p>

  <p>이것을 사용하기 위해서는 SequenceFileInputFormat 을 이용해야한다. (MapFileInputFormat은 존재하지 않는다.)</p>
</blockquote>

<h3 id="multipleoutput">MultipleOutput</h3>
<ul>
  <li>어떤 프로그램에서는 한 현태의 출력파일이 아니라 여러가지 형태의 서로 다른 출력 파일을 명시적으로 만들 수 있다.</li>
</ul>

<h2 id="mrunit-maven">MRUnit과 Maven</h2>

<h3 id="mrunit">MRUnit</h3>
<ul>
  <li>테스트 도구, JUnit과 같다.</li>
  <li>클라우데라에 의해 개발됨. 유닛 테스트 할 때 사용됨</li>
</ul>

<h3 id="section-15">유닛테스트</h3>
<ul>
  <li>소스 코드에서 일종의 단위별로 테스트 하는 것을 유닛 테스트라고 한다.</li>
  <li>큰 모듈을 테스트 하는것이 아니라 작은 클래스나 함수 단위에서 꼭 테스트 해보자는 것이다.</li>
  <li>유닛 테스트 코드를 가팅 추가하는것은 권장되고있고 강제가 될 때도 있다.</li>
  <li>if문의 개수당 테스트를 하기도 하며</li>
  <li>로직의 경로당 테스트를 전부 하느냐 하지않느냐에 따라 테스트 커버리지가 결정되기도 한다.</li>
</ul>

<h3 id="maven">Maven</h3>
<ul>
  <li>빌드 시스템,</li>
  <li>프로젝트 관리도구</li>
</ul>

<h2 id="section-16">그외 기타</h2>

<h3 id="job-tracker-web-interface">job tracker web interface</h3>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>mapred-site.xml</td>
          <td>mapred.job.tracker.http.address 의 값을 수정하면 url이나 포트를 변경할 수 있다.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="section-17">패키지 소스 코드 구분</h3>
<ul>
  <li>
    <p>레거시 코드 
 &gt; org.apache.hadoop.mapred</p>
  </li>
  <li>
    <p>최신 코드
 &gt; org.apache.hadoop.mapreduce</p>
  </li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 하둡.araboza - 4</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-4</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-07T09:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%ED%95%98%EB%91%A1-4</guid>
	  <description><![CDATA[
	     <p>[데이터공작소] 하둡 스터디 자세한 내용은 소스에 주석을 달아 놓았습니다. 소스를 참고해주시기 바랍니다.</p>

<h2 id="chapter-04">Chapter 04</h2>
<p>WordCount 에 대해서 배워본다. 이번장은 소스에 주석으로 진행하였으니 소스를 참고하여 주시기 바랍니다.</p>

<h2 id="section">소스 위치</h2>
<ul>
  <li><a href="https://github.com/drake-jin/hadoop-study/tree/master/week04/wordcount/wordcount/src/wc/MyWordCount.java">소스가 있는곳</a></li>
</ul>

<h2 id="section-1">실행</h2>

<p>``` bash
$ mvn build
$ mvn install
# $ hadoop jar {jar} {main class의 위치} [arg0,arg1,arg2 … arg n]
$ hadoop jar {jar} wc.MyWordCount […args]</p>

<p>```</p>


	  ]]></description>
	</item>

	<item>
	  <title>(스터디) 도커.araboza - 8</title>
	  <link>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-8</link>
	  <author>drakejin</author>
	  <pubDate>2017-05-02T09:00:00+09:00</pubDate>
	  <guid>//%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8F%84%EC%BB%A4-8</guid>
	  <description><![CDATA[
	     <p>[데이터 공작소] 데이터 공작소는 도커는 어떻게 공부할것인가! 처음 시작하는 도커에 대해 공부를 시작합니다.</p>

<h2 id="section">서버 한 대에서 애플리케이션 배포하기</h2>

<p><a href="https://github.com/drake-jin/docker-study/tree/master/ch08">Source 기본적으로 여기에서 참고해서 하세요. </a></p>

<p><code class="highlighter-rouge">bash
$ cd deploySingleServer
</code></p>

<h2 id="section-1">서버 여러 대에서 애플리케이션 배포하기</h2>

<p><code class="highlighter-rouge">bash
$ cd deployMultiServer
</code></p>

	  ]]></description>
	</item>


</channel>
</rss>
